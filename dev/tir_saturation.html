<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bi-saturation (indirect) · spin</title><meta name="title" content="Bi-saturation (indirect) · spin"/><meta property="og:title" content="Bi-saturation (indirect) · spin"/><meta property="twitter:title" content="Bi-saturation (indirect) · spin"/><meta name="description" content="Documentation for spin."/><meta property="og:description" content="Documentation for spin."/><meta property="twitter:description" content="Documentation for spin."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">spin</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li><a class="tocitem" href="bisaturation.html">Bi-saturation (direct)</a></li><li class="is-active"><a class="tocitem" href="tir_saturation.html">Bi-saturation (indirect)</a><ul class="internal"><li><a class="tocitem" href="#Direct-Method-:"><span>Direct Method :</span></a></li><li><a class="tocitem" href="#Indirect-Method-:"><span>Indirect Method :</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="tir_saturation.html">Bi-saturation (indirect)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="tir_saturation.html">Bi-saturation (indirect)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/control-toolbox/spin" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/control-toolbox/spin/blob/main/docs/src/tir_saturation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Saturation-of-pair-of-spins-:-direct-and-indirect-solutions"><a class="docs-heading-anchor" href="#Saturation-of-pair-of-spins-:-direct-and-indirect-solutions">Saturation of pair of spins : direct and indirect solutions</a><a id="Saturation-of-pair-of-spins-:-direct-and-indirect-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Saturation-of-pair-of-spins-:-direct-and-indirect-solutions" title="Permalink"></a></h1><p>Previously, we attempted to solve the bi-saturation problem as mentioned in <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> using a direct method. We will now proceed to solve the same problem using an indirect method, which will require us to use the solution from the direct method as an initial guess. </p><h2 id="Direct-Method-:"><a class="docs-heading-anchor" href="#Direct-Method-:">Direct Method :</a><a id="Direct-Method-:-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Method-:" title="Permalink"></a></h2><p>Let&#39;s first import the necessary packages, <em>OptimalControl</em>, <em>Plots</em> ... : </p><pre><code class="language-julia hljs">using OptimalControl
using Plots
using OrdinaryDiffEq
using LinearAlgebra
using MINPACK
using NLPModelsIpopt</code></pre><p>We will now define the parameters and the functions that we will use later on : </p><pre><code class="language-julia hljs"># Define the parameters of the problem
Γ = 9.855e-2
γ = 3.65e-3
ϵ = 0.1
function F0i(q)
    y, z = q
    res = [-Γ*y, γ*(1-z)]
    return res
end

function F1i(q)
    y, z = q
    res = [-z, y]
    return res
end

F0(q) = [ F0i(q[1:2]); F0i(q[3:4]) ]
F1(q) = [ F1i(q[1:2]); (1 - ϵ) * F1i(q[3:4]) ]
function ocp(q₁₀, q₂₀)
    @def o begin
        tf ∈ R, variable
        t ∈ [0, tf], time
        q = (y₁, z₁, y₂, z₂) ∈ R⁴, state
        u ∈ R, control
        tf ≥ 0
        -1 ≤ u(t) ≤ 1
        qᵢ₁ = [y₁, z₁]
        qᵢ₂ = [y₂, z₂]
        qᵢ₁(0) == q₁₀
        qᵢ₂(0) == q₂₀
        qᵢ₁(tf) == [0, 0]
        qᵢ₂(tf) == [0, 0]
        q̇(t) == F0(q(t)) + u(t) * F1(q(t))
        tf → min
    end
    return o
end
# Function to plot the solution of the optimal control problem
function plot_sol(sol)
    q = sol.state
    liste = [q(t) for t in sol.times]
    liste_y1 = [elt[1] for elt in liste]
    liste_z1 = [elt[2] for elt in liste]
    liste_y2 = [elt[3] for elt in liste]
    liste_z2 = [elt[4] for elt in liste]
    plot(
        plot(liste_y1, liste_z1, xlabel=&quot;y1&quot;, ylabel=&quot;z1&quot;),
        plot(liste_y2, liste_z2, xlabel=&quot;y2&quot;, ylabel=&quot;z2&quot;),
        plot(sol.times, sol.control, xlabel=&quot;Time&quot;, ylabel=&quot;Control&quot;)
    )
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">plot_sol (generic function with 1 method)</code></pre><p>We will use the same technique used before to solve the problem which involves using the solution of the same problem but with a slight change in the initial conditions, as an initial guess. </p><pre><code class="language-julia hljs">prob = ocp([0, 1], [0, 1])
ocp_h = ocp([0.1, 0.9], [0.1, 0.9])
initial_g = solve(ocp_h, grid_size=100)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CTBase.OptimalControlSolution</code></pre><p>The provided code performs an iterative process to refine the solution. </p><pre><code class="language-julia hljs">for i in 1:10
    global initial_g
    solf = solve(prob, grid_size=i*100, init=initial_g)
    initial_g = solf
end
direct_sol = initial_g</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CTBase.OptimalControlSolution</code></pre><p>We will now plot the solution : </p><pre><code class="language-julia hljs">plt = plot(direct_sol, solution_label=&quot;(direct)&quot;, size=(800, 800))</code></pre><img src="tir_saturation-5d4f8298.svg" alt="Example block output"/><h2 id="Indirect-Method-:"><a class="docs-heading-anchor" href="#Indirect-Method-:">Indirect Method :</a><a id="Indirect-Method-:-1"></a><a class="docs-heading-anchor-permalink" href="#Indirect-Method-:" title="Permalink"></a></h2><p>A quick look on the plot of the control u, reveals that the optimal solution consists of a bang arc with minimal control(-1), followed by a singular arc, then another bang arc with maximal control (+1), and the final arc is a singular arc, which means that <strong>we have a solution with a structure of the form BSBS, i.e. Bang-Singular-Bang-Singular</strong> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>.  First, let&#39;s define the Hamiltonian operator. Since : </p><p class="math-container">\[\dot q = F_0(q) + u * F_1(q)\]</p><p>then : </p><p class="math-container">\[H(q,p) = p&#39; * F_0(q) + u * p&#39; * F_1(q)\]</p><p>We&#39;ll note : <span>$H_0(q,p) = p&#39; * F_0(q) $ and $H_1(q,p) = p&#39; * F_1(q)$</span> Let <span>$u_{+} = 1$</span>, the positive bang control (resp. <span>$u_{-} = -1$</span> the negative bang control),  and </p><p class="math-container">\[u_s(q,p) = \frac{H_{001}}{H_{101}} \]</p><p>the singular control, where : <span>$H_{001} ​= {H_0 ​, {H_0​, H_1​}}, H_{101} ​= {H_1​, {H_0​, H_1​}}$</span> and for two Hamiltonien operators <span>$H_0​, H_1$</span> :  </p><p class="math-container">\[\{H_0, H_1\} :=({\nabla}_p H_0  ∣ {\nabla}_x H_1 ) − ({\nabla}_x H_0 ∣ {\nabla}_p H_1)\]</p><p>First, we refine the solution with a higher grid size for better accuracy. We also lift the vector fields to their Hamiltonian counterparts and compute the Lie brackets of these Hamiltonian vector fields. Additionally, we define the singular control function and extract the solution components.</p><pre><code class="language-julia hljs"># Refine the solution with a higher grid size for better accuracy
solution_2000 = solve(prob, grid_size=2000, display=false, init=initial_g)

# Lift the vector fields to their Hamiltonian counterparts
H0 = Lift(F0)
H1 = Lift(F1)

# Compute the Lie brackets of the Hamiltonian vector fields
H01  = @Lie { H0, H1 }
H001 = @Lie { H0, H01 }
H101 = @Lie { H1, H01 }

# Define the singular control function
us(q, p) = -H001(q, p) / H101(q, p)

#~Define the maximum control
umax = 1

# Extract the solution components
t = solution_2000.times
q = solution_2000.state
u = solution_2000.control
p = solution_2000.costate

# Define the flows for maximum, minimum, and singular controls
fₚ = Flow(prob, (q, p, tf) -&gt; umax)
fₘ = Flow(prob, (q, p, tf) -&gt; -umax)
fs = Flow(prob, (q, p, tf) -&gt; us(q, p))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">CTFlows.OptimalControlFlow(CTFlowsODE.var&quot;#f#19&quot;{CTFlowsODE.var&quot;#f#17#20&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, Nothing, Float64, Float64, Vector{Any}}}(CTFlowsODE.var&quot;#f#17#20&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, Nothing, Float64, Float64, Vector{Any}}(Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}(), nothing, 1.0e-10, 1.0e-10, Any[]), Core.Box(CTFlowsODE.var&quot;#f#18#21&quot;(Core.Box(CTFlowsODE.var&quot;#f#19&quot;{CTFlowsODE.var&quot;#f#17#20&quot;{Base.Pairs{Symbol, Union{}, Tuple{}, @NamedTuple{}}, Nothing, Float64, Float64, Vector{Any}}}(#= circular reference @-4 =#))))), CTFlowsODE.var&quot;#rhs!#22&quot;{CTBase.Hamiltonian{CTBase.NonAutonomous, CTBase.NonFixed}}(CTBase.Hamiltonian{CTBase.NonAutonomous, CTBase.NonFixed}(CTFlows.var&quot;#39#40&quot;{CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}, CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}}(CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;##346#5&quot;()), CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;#21#22&quot;())))), Real[], Tuple{Real, Union{Real, AbstractVector{&lt;:Real}}}[], CTBase.ControlLaw{CTBase.Autonomous, CTBase.NonFixed}(Main.var&quot;#21#22&quot;()), CTBase.OptimalControlModel{CTBase.Autonomous, CTBase.NonFixed}
  model_expression: Expr
  initial_time: Int64 0
  initial_time_name: String &quot;0&quot;
  final_time: CTBase.Index
  final_time_name: String &quot;tf&quot;
  time_name: String &quot;t&quot;
  control_dimension: Int64 1
  control_components_names: Array{String}((1,))
  control_name: String &quot;u&quot;
  state_dimension: Int64 4
  state_components_names: Array{String}((4,))
  state_name: String &quot;q&quot;
  variable_dimension: Int64 1
  variable_components_names: Array{String}((1,))
  variable_name: String &quot;tf&quot;
  lagrange: Nothing nothing
  mayer: CTBase.Mayer{CTBase.NonFixed}
  criterion: Symbol min
  dynamics: CTBase.Dynamics{CTBase.Autonomous, CTBase.NonFixed}
  constraints: Dict{Symbol, Tuple}
  dim_control_constraints: Int64 0
  dim_state_constraints: Int64 0
  dim_mixed_constraints: Int64 0
  dim_boundary_constraints: Int64 8
  dim_variable_constraints: Int64 0
  dim_control_range: Int64 1
  dim_state_range: Int64 0
  dim_variable_range: Int64 1
)</code></pre><p>Next, we define a function to compute the shooting function for the indirect method. This function calculates the state and costate at the switching times and populates the shooting function residuals.</p><pre><code class="language-julia hljs"># Function to compute the shooting function for the indirect method
function shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
    qi1, pi1 = fₘ(0, q0, p0, t1)
    qi2, pi2 = fs(t1, q1, p1, t2)
    qi3, pi3 = fₚ(t2, q2, p2, t3)
    qf, pf = fs(t3, q3, p3, tf)
    s[1] = H0(q0, p0) - umax * H1(q0, p0) - 1
    s[2] = H1(q1, p1)
    s[3] = H01(q1, p1)
    s[4] = H1(q3, p3)
    s[5] = H01(q3, p3)
    s[6] = qf[3]
    s[7] = qf[4]
    s[8] = (pf[2] + pf[4]) * γ - 1
    s[9:12] = qi1 - q1
    s[13:16] = pi1 - p1
    s[17:20] = qi2 - q2
    s[21:24] = pi2 - p2
    s[25:28] = qi3 - q3
    s[29:32] = pi3 - p3
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">shoot! (generic function with 1 method)</code></pre><p>We then initialize parameters to find the switching times. We identify the intervals where the control is near zero, indicating singular control, and determine the switching times.</p><pre><code class="language-julia hljs"># Initialize parameters for finding switching times
t0 = 0
tol = 2e-2

# Find times where control is near zero (singular control)
t13 = [elt for elt in t if abs(u(elt)) &lt; tol]
i = 1
t_l = []

# Identify intervals for switching times
while(true)
    global i
    if (( i == length(t13)-1) || (t13[i+1] - t13[i] &gt; 1) )
        break
    else
        push!(t_l, t13[i])
        push!(t_l, t13[i+1])
        i += 1
    end
end

# Determine the switching times
t1 = min(t_l...)
t2 = max(t_l...)
t3f = [elt for elt in t13 if elt &gt; t2]
t3 = min(t3f...)

# Extract initial and intermediate costates and states and final time
p0 = p(t0)
q0 = [0, 1, 0, 1]
tf = solution_2000.objective
q1, p1 = q(t1), p(t1)
q2, p2 = q(t2), p(t2)
q3, p3 = q(t3), p(t3)
println(&quot;p0 = &quot;, p0)
println(&quot;t1 = &quot;, t1)
println(&quot;t2 = &quot;, t2)
println(&quot;t3 = &quot;, t3)
println(&quot;tf = &quot;, tf)
p0[1], q0[1], p0[3], q0[3]= -p0[1], -q0[1], -p0[3], -q0[3]
p1[1], q1[1], p1[3], q1[3]= -p1[1], -q1[1], -p1[3], -q1[3]
p2[1], q2[1], p2[3], q2[3]= -p2[1], -q2[1], -p2[3], -q2[3]
p3[1], q3[1], p3[3], q3[3]= -p3[1], -q3[1], -p3[3], -q3[3]
println(&quot;p1 = &quot;, p1)
println(&quot;p2 = &quot;, p2)
println(&quot;p3 = &quot;, p3)
println(&quot;q1 = &quot;, q1)
println(&quot;q2 = &quot;, q2)
println(&quot;q3 = &quot;, q3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">p0 = [-1.968383560336647, -2.683692907466549, 1.1803810797798746, -7.176679681378337]
t1 = 1.8130555753978281
t2 = 9.580096126793462
t3 = 13.116673668927497
tf = 44.76680433081057
p1 = [-3.2067039050168398, -1.4316659011815034, -7.956137909735359, 1.8021258736574164]
p2 = [-6.991481857716248, -1.2139257627069924, -16.97332743064174, 2.424325222362661]
p3 = [7.558507058306593, 4.145079552523258, 20.35037615948182, -3.0629744814364352]
q1 = [0.8969201946962829, -0.13457054048880976, 0.9147640412814327, 0.032421449024528114]
q2 = [0.4122990039199879, -0.13217669121849873, 0.42655420210443407, 0.03240827239012222]
q3 = [-0.3615752273548799, -0.00949384631677018, -0.36298635967748877, -0.023253682915612892]</code></pre><p>Next, we initialize the shooting function residuals and compute the initial residuals for the shooting function to verify the solution&#39;s accuracy. </p><pre><code class="language-julia hljs"># Initialize the shooting function residuals
s = similar(p0, 32)

# Compute the initial residuals for the shooting function
shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Using arrays or dicts to store parameters of different types can hurt performance.
│ Consider using tuples instead.
└ @ SciMLBase ~/.julia/packages/SciMLBase/n3SyK/src/performance_warnings.jl:33
┌ Warning: At t=39.530922799734995, dt was forced below floating point epsilon 7.105427357601002e-15, and step error estimate = 336.0731230405958. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).
└ @ SciMLBase ~/.julia/packages/SciMLBase/n3SyK/src/integrator_interface.jl:600
Norm of the shooting function: ‖s‖ = 1.109019694739302</code></pre><p>We define a nonlinear equation solver for the shooting method. This solver refines the initial costate and switching times to find the optimal solution using the shooting function.</p><pre><code class="language-julia hljs"># Define a nonlinear equation solver for the shooting method
nle = (s, ξ) -&gt; shoot!(s, ξ[1:4], ξ[5], ξ[6], ξ[7], ξ[8], ξ[9:12], ξ[13:16], ξ[17:20], ξ[21:24], ξ[25:28], ξ[29:32])
ξ = [ p0 ; t1 ; t2 ; t3 ; tf ; q1 ; p1 ; q2 ; p2 ; q3 ; p3 ]
# Solve the shooting equations to find the optimal times and costate

indirect_sol = fsolve(nle, ξ; show_trace=true , tol=1e-6)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Results of Nonlinear Solver Algorithm
 * Algorithm: Modified Powell
 * Starting Point: [1.968383560336647, -2.683692907466549, -1.1803810797798746, -7.176679681378337, 1.8130555753978281, 9.580096126793462, 13.116673668927497, 44.76680433081057, 0.8969201946962829, -0.13457054048880976, 0.9147640412814327, 0.032421449024528114, -3.2067039050168398, -1.4316659011815034, -7.956137909735359, 1.8021258736574164, 0.4122990039199879, -0.13217669121849873, 0.42655420210443407, 0.03240827239012222, -6.991481857716248, -1.2139257627069924, -16.97332743064174, 2.424325222362661, -0.3615752273548799, -0.00949384631677018, -0.36298635967748877, -0.023253682915612892, 7.558507058306593, 4.145079552523258, 20.35037615948182, -3.0629744814364352]
 * Zero: [2.4386471449899254, -2.5449963687305024, -1.6897572171589104, -7.231929319511844, 1.7725155428642607, 10.24248084079377, 13.739036676848956, 9922.870895830605, 0.896657153436109, -0.1361475407914288, 0.914708933370698, 0.030727944982581575, -3.1424826073924983, -1.9627516538821248, -8.019873750770973, 2.3873158139094914, 0.38503360956922517, -0.13232882611443053, 0.39978831281665733, 0.03140072682511751, -7.319061054095933, -1.7324409858285816, -18.165453418079107, 3.118713967256021, -0.3127529983250676, -0.028390124088574404, -0.34011253160653915, -0.011187524743349823, 7.676833682009039, 4.9191492211564185, 21.81788936032515, -3.6959403502684025]
 * Inf-norm of residuals: 0.216770
 * Convergence: false
 * Message: iteration is not making good progress
 * Total time: 142.361141 seconds
 * Function Calls: 29
 * Jacobian Calls (df/dx): 8</code></pre><p>We extract the refined initial costate and switching times from the solution. We then recompute the residuals for the shooting function to ensure the accuracy of the refined solution. Therefore, we conclude that this solution is more accurate, as the norm of <em>s</em> in this case is smaller than the previously computed one using the direct method.</p><pre><code class="language-julia hljs"># Extract the refined initial costate and switching times from the solution
p0 = indirect_sol.x[1:4]
t1 = indirect_sol.x[5]
t2 = indirect_sol.x[6]
t3 = indirect_sol.x[7]
tf = indirect_sol.x[8]
q1, p1, q2, p2, q3, p3 = indirect_sol.x[9:12], indirect_sol.x[13:16], indirect_sol.x[17:20], indirect_sol.x[21:24], indirect_sol.x[25:28], indirect_sol.x[29:32]

# Recompute the residuals for the shooting function
s = similar(p0, 32)
shoot!(s, p0, t1, t2, t3, tf, q1, p1, q2, p2, q3, p3)
println(&quot;Norm of the shooting function: ‖s‖ = &quot;, norm(s), &quot;\n&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">┌ Warning: Using arrays or dicts to store parameters of different types can hurt performance.
│ Consider using tuples instead.
└ @ SciMLBase ~/.julia/packages/SciMLBase/n3SyK/src/performance_warnings.jl:33
┌ Warning: At t=100.46470821028124, dt was forced below floating point epsilon 1.4210854715202004e-14, and step error estimate = 17.47041826970698. Aborting. There is either an error in your model specification or the true solution is unstable (or the true solution can not be represented in the precision of Float64).
└ @ SciMLBase ~/.julia/packages/SciMLBase/n3SyK/src/integrator_interface.jl:600
Norm of the shooting function: ‖s‖ = 0.3541048503432239</code></pre><p>Finally, we define the composed flow solution using the switching times and controls. We compute the flow solution over the time interval and plot both the direct and indirect solutions for comparison.</p><pre><code class="language-julia hljs"># Define the composed flow solution using the switching times and controls
f_sol = fₘ * (t1, fs) * (t2, fₚ) * (t3, fs)

# Compute the flow solution over the time interval
flow_sol = f_sol((t0, tf), q0, p0)

# Plot the direct and indirect solutions for comparison
plt = plot(solution_2000, solution_label=&quot;(direct)&quot;)
plot(plt, flow_sol, solution_label=&quot;(indirect)&quot;)</code></pre><img src="tir_saturation-c1df5476.svg" alt="Example block output"/><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Bernard Bonnard, Olivier Cots, Jérémy Rouot, Thibaut Verron. Time minimal saturation of a pair of spins and application in magnetic resonance imaging. Mathematical Control and Related Fields, 2020, 10 (1), pp.47-88.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="bisaturation.html">« Bi-saturation (direct)</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Tuesday 23 July 2024 12:35">Tuesday 23 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
